%{
%}

// The start symbol (or non-terminal):
%start start

// Names of tokens (or terminals):
%token <int> INT
%token <string> NAME
%token LET DEF FUNC IN IF THEN ELSE
%token SEMICOL
%token PLUS MINUS STAR LPAR RPAR HAT DIV
%token EQ
%token EOF



// Associativity and precedence:
%left PLUS MINUS
%left STAR
%right HAT
%left DIV

// Declaring the types of the values produced by the different
// symbols:
%type <(Syntax.funcDef list * Syntax.exp)> start
%type <Syntax.exp> exp
%type <Syntax.funcDef list> FDS
%type <Syntax.funcDef> funcDef

%%

// Grammar rules along with the F# code to execute when they are
// reduced:
start
  : FDS exp EOF                   { $1, $2 }

FDS
  :                            { [] }
  | funcDef FDS                { $1::$2 }
  

funcDef
  : FUNC NAME LPAR NAME RPAR DEF exp SEMICOL     { Syntax.funcDef($2, ($4, $7)) }
  
exp
  : INT                       { Syntax.INT $1 }
  | LPAR exp RPAR             { $2 }
  | NAME                      { Syntax.VAR $1 }
  | LET NAME DEF exp IN exp   { Syntax.LET($2, $4, $6) }  // Interpreter.evalProg ([],  (Parse.fromString("let x = 5 in 2 + x")));;  does not work
  | exp PLUS exp              { Syntax.ADD($1, $3) }
  | exp MINUS exp             { Syntax.SUB($1, $3) }
  | exp STAR exp              { Syntax.MUL($1, $3) }
  | exp HAT exp               { Syntax.EXP($1, $3) }
  | exp EQ exp                { Syntax.EQ ($1, $3) }
  | exp DIV exp               { Syntax.DIV($1, $3) }
  | IF exp THEN exp ELSE exp  { Syntax.IF ($2, $4, $6) }
  // | exp LN exp                { $3 }
  // | CMNT_S exp CMNT_E         {}
  | NAME LPAR exp RPAR        { Syntax.CALL($1,$3) }
