%{
%}

// The start symbol (or non-terminal):
%start start

// Names of tokens (or terminals):
%token <int> INT
%token <string> NAME
%token LET DEF FUNC IN IF THEN ELSE
%token SEMICOL
%token PLUS MINUS STAR LPAR RPAR HAT DIV MOD
%token EQ NEQ LT GT LTEQ GTEQ AND OR
%token EOF



// Associativity and precedence:
%left PLUS MINUS
%left STAR
%right HAT
%left DIV

// Declaring the types of the values produced by the different
// symbols:
%type <(Syntax.funcDef list * Syntax.exp)> start
%type <Syntax.exp> exp
%type <Syntax.funcDef list> FDS
%type <Syntax.funcDef> funcDef

%%

// Grammar rules along with the F# code to execute when they are
// reduced:
start
  : FDS exp EOF                   { $1, $2 }

FDS
  :                            { [] }
  | funcDef FDS                { $1::$2 }
  

funcDef
  : FUNC NAME LPAR NAME RPAR DEF exp SEMICOL     { Syntax.funcDef($2, ($4, $7)) }
  
exp
  : INT                       { Syntax.INT $1 }
  | LPAR exp RPAR             { $2 }
  | NAME                      { Syntax.VAR $1 }
  | LET NAME DEF exp IN exp   { Syntax.LET($2, $4, $6) }
  | exp PLUS exp              { Syntax.ADD($1, $3) }
  | exp MINUS exp             { Syntax.SUB($1, $3) }
  | exp STAR exp              { Syntax.MUL($1, $3) }
  | exp HAT exp               { Syntax.EXP($1, $3) }
  | exp EQ exp                { Syntax.EQ ($1, $3) }
  | exp DIV exp               { Syntax.DIV($1, $3) }
  | IF exp THEN exp ELSE exp  { Syntax.IF ($2, $4, $6) }
  | NAME LPAR exp RPAR        { Syntax.CALL($1, $3) }
  //| WRITE LPAR NAME RPAR      { Syntax.WRITE($3) }
  //| exp COMMA exp             { Syntax.COMMA($1, $3) }
  | exp NEQ exp               { Syntax.NEQ($1, $3) }
  | exp MOD exp               { Syntax.MOD($1, $3) }
  | exp LT exp                { Syntax.LT($1, $3) }
  | exp LTEQ exp              { Syntax.LTEQ($1, $3) }
  | exp GT exp                { Syntax.GT($1, $3) }
  | exp GTEQ exp              { Syntax.GTEQ($1, $3) }
  | exp AND exp               { Syntax.AND($1, $3) }
  | exp OR exp                { Syntax.OR($1, $3) }

